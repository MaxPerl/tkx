=head1 NAME

Tkx::Tutorial - How to use Tkx

=head1 DESCRIPTION

I<Tk> is a toolkit that allows you to create applications with
graphical interfaces.  The C<Tk> toolkit is native to the Tcl
programming language, but its ease of use has made it the GUI toolkit
of choice for many other dynamic languages as well.

C<Tkx> is a Perl module that make the I<Tk> toolkit available to perl.
By loading the C<Tkx> module perl programs can create windows and fill
them with text, images, buttons and other controls that make up the
user interface of the application.

=head2 Hello, world

Let's start with the mandatory exercise of creating an application
that greats the world.  In our case we make the application window
contain a single button which will shut down the application if
clicked.  The code to make this happen is:

  use Tkx;

  Tkx::button(".b",
      -text => "Hello, world",
      -command => sub { Tkx::destroy("."); },
  );
  Tkx::pack(".b");

  Tkx::MainLoop()

Save this to a file called F<hello.pl> and then run C<perl hello.pl>
to start up the application.  A window with the text "Hello, world"
should appear on your screen.

After the C<Tkx> module has been loaded the application will show an
empty window called ".".  We create a I<button> with the name ".b" and
tell the window to display this with I<pack>.  In the end we need to
pass control back to I<Tk> so that it can draw the window and invoke
our callback if the button is clicked.  The application will terminate
when the window is destroyed.

For reference this is how the same program would look in Tcl:

  package require Tk

  button .b \
      -text "Hello, world" \
      -command { destroy . }
  pack .b

This program can be executed by the F<tclsh> binary that comes with
I<Tcl/Tk>.  As you can see the code is mostly identical, but with a
slightly different syntax.  The only real difference is that the call
to MainLoop() is implicit in Tcl and does not have to be spelled out.

C<Tkx> does not come with documentation that explain all the widgets
(like "button" above) that are available for use.  Instead you will
need to read the excellent documentation that comes with C<Tcl/Tk> and
then figure out how this translates to C<Tkx> yourself.  As you can
see this translation is straight forward.  You basically only have add
the prefix "Tkx::" to all the functions and use the Perl way of
passing arguments.  Tcl is a very simple language, so it should not
take long to understand enough of it to be able to read its
documentation with ease.

=head2 Hello, world with objects

The windows and controls that make up a C<Tk> interface are called
I<widgets>.  The widgets are identified by path names of the form
C<.a.b.c>.  These names are hierarchical in the same way as file
system names are, but "." is used instead of "/" to separate levels.
The name C<.a.b.c> is the name of a widget that is child of widget
C<.a.b> which in turn is a child of C<.a>.  At the top of this
hierarchy we have a widget called C<.>, which is the main window of
the application.

The C<Tkx> module provide a class called C<Tkx::widget>.  By utilizing
objects of this class we can hide the details of Tk path names from
C<Tkx> applications.  This provide a more "perlish" way to create and
manipulate Tk widgets.

Our "Hello, world" program can be rewitten like this using the
C<Tkx::widget> class:

  use Tkx;

  my $mw = Tkx::widget->new(".");
  my $b = $mw->new_button(
      -text => "Hello, world",
      -command => sub { $mw->g_destroy; },
  );
  $b->g_pack;

  Tkx::MainLoop()

By loading the C<Tkx> module we make the C<Tkx::widget> class
available and create the main window (the widget called C<.>).  Next
we instantiate a new C<Tkx::widget> object wrapping the main window.
It is customary to name this object C<$mw>.

To create a new button child widget we call C<< $mw->new_button >>
method.  Constructor methods are always prefixed with C<new_>.  The rest
of the method name is the name of the I<Tk> widget to create; i.e. "button"
in this case.  Arguments are passed as before.

Calling a "g_" method will invoke the correspoding Tk command with the
widget path as argument.  In the code above we destroy the main window
by calling C<< $mw->g_destroy >> and we pack the button in the main
window by invoking C<< $b->g_pack >>.

Calling a "m_" method will invoke a Tk subcommand for the given
widget, but there is no example of this is the code above.  The most
commonly used subcommand is "configure" that is used to change the
attributes of a widget.  We could for instace change the text
displayed by the button by invoking:

  $b->m_configure(-text => "Goodbye, cruel world");

In the end we need to invoke the MainLoop as before.

For trivial programs like the one above using C<Tkx::widget> wrappers
does not appear to be a win, but as the application grows and the Tk
path names get longer it surely is.

=head1 SEE ALSO

L<Tkx>
